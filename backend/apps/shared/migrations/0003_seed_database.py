# Generated by Django 5.1.6 on 2025-03-18 20:26

import csv
import os
import glob
from datetime import datetime
from decimal import Decimal

from django.apps import apps
from django.db import migrations, transaction
from django.db.models import Model


def get_model_field_types(model):
    """Get field types for a Django model"""
    field_types = {}
    for field in model._meta.get_fields():
        if hasattr(field, 'name') and not field.is_relation:
            field_types[field.name] = field.get_internal_type()
    return field_types


def convert_value(value, field_type):
    """Convert string value to appropriate type based on field type"""
    if value is None or value == '':
        return None
    
    if field_type in ('CharField', 'TextField'):
        return str(value)
    elif field_type == 'IntegerField':
        try:
            return int(value)
        except (ValueError, TypeError):
            return None
    elif field_type in ('DecimalField', 'FloatField'):
        try:
            return Decimal(value)
        except (ValueError, TypeError):
            return None
    elif field_type == 'BooleanField':
        return value.lower() in ('true', 't', 'yes', 'y', '1')
    elif field_type == 'DateField':
        try:
            return datetime.strptime(value, '%Y-%m-%d').date()
        except (ValueError, TypeError):
            return None
    elif field_type == 'DateTimeField':
        try:
            return datetime.strptime(value, '%Y-%m-%d %H:%M:%S')
        except (ValueError, TypeError):
            try:
                return datetime.strptime(value, '%Y-%m-%d')
            except (ValueError, TypeError):
                return None
    else:
        return value


def import_csv_to_model(csv_path, model, clear_table=True):
    """Import data from CSV file to Django model"""
    if not os.path.exists(csv_path):
        print(f"Warning: CSV file not found: {csv_path}")
        return 0
    
    # Clear existing data if requested
    if clear_table:
        model.objects.all().delete()
    
    field_types = get_model_field_types(model)
    count = 0
    
    with open(csv_path, 'r') as csv_file:
        reader = csv.DictReader(csv_file)
        
        # Process in batches for better performance
        batch_size = 500
        batch = []
        
        for row in reader:
            # Convert all values to appropriate types
            obj_data = {}
            for field, value in row.items():
                if field in field_types:
                    obj_data[field] = convert_value(value, field_types[field])
            
            if obj_data:
                batch.append(model(**obj_data))
                count += 1
                
                if len(batch) >= batch_size:
                    model.objects.bulk_create(batch)
                    batch = []
        
        # Create remaining objects
        if batch:
            model.objects.bulk_create(batch)
    
    return count


def find_latest_csv_file(directory):
    """Find the latest CSV file in a directory or direct file path"""
    # Check if the directory is actually a CSV file
    if directory.endswith('.csv') and os.path.isfile(directory):
        return directory
        
    # Check if there's a direct CSV file with the directory name
    direct_file = f"{directory}.csv"
    if os.path.isfile(direct_file):
        return direct_file
    
    # Traditional directory search
    csv_files = glob.glob(os.path.join(directory, '*.csv'))
    if not csv_files:
        return None
    return max(csv_files, key=os.path.getmtime)


def seed_database(apps, schema_editor):
    """Seed database with data from CSV files"""
    # Map directory names to model path - only include models that exist
    directory_to_model = {
        '_Crops': 'crops.Crops',
        '_ConversionFactors': 'crops.ConversionFactors',
        '_CropTypes': 'crops.CropTypes',
        '_CropYields': 'crops.CropYields',
        '_CropSoilTestPotassiumRegions': 'crops.CropSoilPotassiumRegions',
        '_CropSoilTestPhosphorousRegions': 'crops.CropSoilTestPhosphorousRegions',
        '_Regions': 'shared.Regions',
        '_SubRegion': 'shared.SubRegion',
        '_Animals': 'animals.Animals',
        '_AnimalSubType': 'animals.AnimalSubtype',
        '_Breed': 'animals.Breed',
        '_Manures': 'manures.Manures',
        '_LiquidMaterialsConversionFactors': 'manures.LiquidMaterialsConversionFactors',
        '_SolidMaterialsConversionFactors': 'manures.SolidMaterialsConversionFactors',
        '_Fertilizers': 'fertilizers.Fertilizers',
        '_FertilizerTypes': 'fertilizers.FertilizerTypes',
        '_FertilizerUnits': 'fertilizers.FertilizerUnits',
        '_NitrogenRecommendations': 'crops.NitrogenRecommendation',
        '_SoilTestMethods': 'crops.SoilTestMethods',
        '_SoilTestPhosphorousKelownaRanges': 'crops.SoilTestPhosphorousKelownaRanges',
        '_SoilTestPhosphorousRecommendation': 'crops.SoilTestPhosphorousRecommendation',
        '_SoilTestPotassiumKelownaRanges': 'crops.SoilTestPotassiumKelownaRanges',
        '_SoilTestPotassiumRecommendation': 'crops.SoilTestPotassiumRecommendation',
        '_Previous_Crop_Types': 'crops.PreviousCropTypes',
    }
    
    # Check multiple potential locations for CSV files
    base_dirs = [
        '/app/database/db/trimmed_tables',  # Docker volume mount path
        '/docker-entrypoint-initdb.d',      # PostgreSQL init path
        '/opt/app-root/src/database/db/trimmed_tables'  # OpenShift path
    ]
    
    # Use the first directory that exists
    base_dir = None
    for path in base_dirs:
        if os.path.exists(path):
            base_dir = path
            print(f"Using CSV directory: {base_dir}")
            break
    
    if not base_dir:
        print("No valid CSV directory found. Data seeding will be skipped.")
        return
    
    total_count = 0
    errors = 0
    
    for directory, model_path in directory_to_model.items():
        try:
            # Get model
            app_label, model_name = model_path.split('.')
            model = apps.get_model(app_label, model_name)
            
            # Try different path structures
            possible_paths = [
                os.path.join(base_dir, directory),  # /path/to/dir/_ModelName/
                os.path.join(base_dir, f"{directory}.csv"),  # /path/to/dir/_ModelName.csv
                os.path.join(base_dir, directory.lstrip('_') + ".csv"),  # /path/to/dir/ModelName.csv
            ]
            
            csv_file = None
            for path in possible_paths:
                if os.path.exists(path):
                    if path.endswith('.csv'):
                        csv_file = path
                    else:
                        csv_file = find_latest_csv_file(path)
                    if csv_file:
                        break
            
            if csv_file:
                count = import_csv_to_model(csv_file, model, clear_table=True)
                print(f"Imported {count} records into {model_path} from {csv_file}")
                total_count += count
            else:
                print(f"No CSV file found in {base_dir} for {directory}")
        except Exception as e:
            print(f"Error importing {model_path}: {str(e)}")
            errors += 1
    
    print(f"Total records imported: {total_count}")
    print(f"Total errors: {errors}")


def reverse_seed_database(apps, schema_editor):
    """Clear all data that was seeded"""
    # Include only models that exist
    directory_to_model = {
        '_Crops': 'crops.Crops',
        '_ConversionFactors': 'crops.ConversionFactors',
        '_CropTypes': 'crops.CropTypes',
        '_CropYields': 'crops.CropYields',
        '_CropSoilTestPotassiumRegions': 'crops.CropSoilPotassiumRegions',
        '_CropSoilTestPhosphorousRegions': 'crops.CropSoilTestPhosphorousRegions',
        '_Regions': 'shared.Regions',
        '_SubRegion': 'shared.SubRegion',
        '_Animals': 'animals.Animals',
        '_AnimalSubType': 'animals.AnimalSubtype',
        '_Breed': 'animals.Breed',
        '_Manures': 'manures.Manures',
        '_LiquidMaterialsConversionFactors': 'manures.LiquidMaterialsConversionFactors',
        '_SolidMaterialsConversionFactors': 'manures.SolidMaterialsConversionFactors',
        '_Fertilizers': 'fertilizers.Fertilizers',
        '_FertilizerTypes': 'fertilizers.FertilizerTypes',
        '_FertilizerUnits': 'fertilizers.FertilizerUnits',
        '_NitrogenRecommendations': 'crops.NitrogenRecommendation',
        '_SoilTestMethods': 'crops.SoilTestMethods',
        '_SoilTestPhosphorousKelownaRanges': 'crops.SoilTestPhosphorousKelownaRanges',
        '_SoilTestPhosphorousRecommendation': 'crops.SoilTestPhosphorousRecommendation',
        '_SoilTestPotassiumKelownaRanges': 'crops.SoilTestPotassiumKelownaRanges',
        '_SoilTestPotassiumRecommendation': 'crops.SoilTestPotassiumRecommendation',
        '_Previous_Crop_Types': 'crops.PreviousCropTypes',
    }
    
    for directory, model_path in directory_to_model.items():
        try:
            app_label, model_name = model_path.split('.')
            model = apps.get_model(app_label, model_name)
            model.objects.all().delete()
            print(f"Cleared all data from {model_path}")
        except Exception as e:
            print(f"Error clearing {model_path}: {str(e)}")


class Migration(migrations.Migration):

    dependencies = [
        ('shared', '0002_alter_regions_options_alter_subregion_options'),
    ]

    operations = [
        migrations.RunPython(
            seed_database,
            reverse_seed_database,
        ),
    ]
