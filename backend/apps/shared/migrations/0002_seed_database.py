# Generated by Django 5.1.7 on 2025-03-20 18:50

import csv
import os
import glob
from decimal import Decimal
from datetime import datetime

from django.db import migrations, transaction


def get_model_field_types(model):
    """Get field types for a Django model"""
    field_types = {}
    for field in model._meta.get_fields():
        if hasattr(field, 'name') and not field.is_relation:
            field_types[field.name] = field.get_internal_type()
    return field_types


def convert_value(value, field_type):
    """Convert string value to appropriate type based on field type"""
    if value is None or value == '':
        return None
    
    if field_type in ('CharField', 'TextField'):
        return str(value)
    elif field_type == 'IntegerField':
        try:
            return int(value)
        except (ValueError, TypeError):
            return None
    elif field_type in ('DecimalField', 'FloatField'):
        try:
            return Decimal(value)
        except (ValueError, TypeError):
            return None
    elif field_type == 'BooleanField':
        return value.lower() in ('true', 't', 'yes', 'y', '1')
    elif field_type == 'DateField':
        try:
            return datetime.strptime(value, '%Y-%m-%d').date()
        except (ValueError, TypeError):
            return None
    elif field_type == 'DateTimeField':
        try:
            return datetime.strptime(value, '%Y-%m-%d %H:%M:%S')
        except (ValueError, TypeError):
            try:
                return datetime.strptime(value, '%Y-%m-%d')
            except (ValueError, TypeError):
                return None
    else:
        return value


def import_csv_to_model(csv_path, model, clear_table=True):
    """Import data from CSV file to Django model"""
    if not os.path.exists(csv_path):
        print(f"Warning: CSV file not found: {csv_path}")
        return 0
    
    # Clear existing data if requested
    if clear_table:
        model.objects.all().delete()
    
    field_types = get_model_field_types(model)
    count = 0
    errors = 0
    
    with open(csv_path, 'r') as csv_file:
        reader = csv.DictReader(csv_file)
        
        # Process in batches for better performance
        batch_size = 500
        batch = []
        
        for row in reader:
            try:
                # Convert all values to appropriate types
                obj_data = {}
                for field, value in row.items():
                    if field in field_types:
                        obj_data[field] = convert_value(value, field_types[field])
                
                # Set default values for NULL fields that are required
                # This is specifically for the manures table defaultsolidmoisture issue
                if 'defaultsolidmoisture' in obj_data and obj_data['defaultsolidmoisture'] is None:
                    obj_data['defaultsolidmoisture'] = 0  # Default value
                
                if obj_data:
                    batch.append(model(**obj_data))
                    count += 1
                    
                    if len(batch) >= batch_size:
                        try:
                            with transaction.atomic():
                                model.objects.bulk_create(batch)
                        except Exception as e:
                            print(f"Error importing batch: {str(e)}")
                            errors += len(batch)
                        batch = []
            except Exception as e:
                print(f"Error processing row: {str(e)}")
                errors += 1
        
        # Create remaining objects
        if batch:
            try:
                with transaction.atomic():
                    model.objects.bulk_create(batch)
            except Exception as e:
                print(f"Error importing final batch: {str(e)}")
                errors += len(batch)
    
    if errors > 0:
        print(f"Warning: {errors} records could not be imported")
    
    return count


def find_csv_files(base_dir, directory_name):
    """Find CSV files for a model in multiple potential locations"""
    # Check for directory
    dir_path = os.path.join(base_dir, directory_name)
    if os.path.isdir(dir_path):
        csv_files = glob.glob(os.path.join(dir_path, '*.csv'))
        if csv_files:
            return max(csv_files, key=os.path.getmtime)
    
    # Check for direct CSV file with directory name
    file_path = os.path.join(base_dir, f"{directory_name}.csv")
    if os.path.isfile(file_path):
        return file_path
    
    # Check for CSV without underscore prefix
    clean_name = directory_name.lstrip('_')
    file_path = os.path.join(base_dir, f"{clean_name}.csv")
    if os.path.isfile(file_path):
        return file_path
    
    return None


def seed_database(apps, schema_editor):
    """Seed database with data from CSV files"""
    # Map directory names to model path
    directory_to_model = {
        '_Crops': 'crops.Crops',
        '_ConversionFactors': 'crops.ConversionFactors',
        '_CropTypes': 'crops.CropTypes',
        '_CropYields': 'crops.CropYields',
        '_CropSoilTestPotassiumRegions': 'crops.CropSoilPotassiumRegions',
        '_CropSoilTestPhosphorousRegions': 'crops.CropSoilTestPhosphorousRegions',
        '_Regions': 'shared.Regions',
        '_SubRegion': 'shared.SubRegion',
        '_Animals': 'animals.Animals',
        '_AnimalSubType': 'animals.AnimalSubtype',
        '_Breed': 'animals.Breed',
        '_Manures': 'manures.Manures',
        '_LiquidMaterialsConversionFactors': 'manures.LiquidMaterialsConversionFactors',
        '_SolidMaterialsConversionFactors': 'manures.SolidMaterialsConversionFactors',
        '_Fertilizers': 'fertilizers.Fertilizers',
        '_FertilizerTypes': 'fertilizers.FertilizerTypes',
        '_FertilizerUnits': 'fertilizers.FertilizerUnits',
        '_NitrogenRecommendations': 'crops.NitrogenRecommendation',
        '_SoilTestMethods': 'crops.SoilTestMethods',
        '_SoilTestPhosphorousKelownaRanges': 'crops.SoilTestPhosphorousKelownaRanges',
        '_SoilTestPhosphorousRecommendation': 'crops.SoilTestPhosphorousRecommendation',
        '_SoilTestPotassiumKelownaRanges': 'crops.SoilTestPotassiumKelownaRanges',
        '_SoilTestPotassiumRecommendation': 'crops.SoilTestPotassiumRecommendation',
        '_Previous_Crop_Types': 'crops.PreviousCropTypes',
    }
    
    # Check multiple potential locations for CSV files
    base_dirs = [
        '/app/database/db/trimmed_tables',  # Docker volume mount
        '/docker-entrypoint-initdb.d',      # PostgreSQL init directory
        '/opt/app-root/src/database/db/trimmed_tables',  # OpenShift path
    ]
    
    # Find the first usable base directory
    base_dir = None
    for path in base_dirs:
        if os.path.exists(path):
            base_dir = path
            print(f"Using CSV directory: {base_dir}")
            break
    
    if not base_dir:
        print("No valid CSV directory found. Seeding skipped.")
        return
    
    total_count = 0
    total_errors = 0
    
    for directory, model_path in directory_to_model.items():
        # Use a separate transaction for each model to prevent cascading failures
        with transaction.atomic():
            try:
                # Get model
                app_label, model_name = model_path.split('.')
                model = apps.get_model(app_label, model_name)
                
                # Look for CSV file in various formats
                csv_file = find_csv_files(base_dir, directory)
                
                if csv_file:
                    count = import_csv_to_model(csv_file, model, clear_table=True)
                    print(f"Imported {count} records into {model_path} from {csv_file}")
                    total_count += count
                else:
                    print(f"No CSV file found for {directory}")
            except Exception as e:
                print(f"Error importing {model_path}: {str(e)}")
                total_errors += 1
    
    print(f"Total records imported: {total_count}")
    print(f"Total model errors: {total_errors}")


def reverse_seed_database(apps, schema_editor):
    """Clear all data that was seeded"""
    # Map directory names to model path
    directory_to_model = {
        '_Crops': 'crops.Crops',
        '_ConversionFactors': 'crops.ConversionFactors',
        '_CropTypes': 'crops.CropTypes',
        '_CropYields': 'crops.CropYields',
        '_CropSoilTestPotassiumRegions': 'crops.CropSoilPotassiumRegions',
        '_CropSoilTestPhosphorousRegions': 'crops.CropSoilTestPhosphorousRegions',
        '_Regions': 'shared.Regions',
        '_SubRegion': 'shared.SubRegion',
        '_Animals': 'animals.Animals',
        '_AnimalSubType': 'animals.AnimalSubtype',
        '_Breed': 'animals.Breed',
        '_Manures': 'manures.Manures',
        '_LiquidMaterialsConversionFactors': 'manures.LiquidMaterialsConversionFactors',
        '_SolidMaterialsConversionFactors': 'manures.SolidMaterialsConversionFactors',
        '_Fertilizers': 'fertilizers.Fertilizers',
        '_FertilizerTypes': 'fertilizers.FertilizerTypes',
        '_FertilizerUnits': 'fertilizers.FertilizerUnits',
        '_NitrogenRecommendations': 'crops.NitrogenRecommendation',
        '_SoilTestMethods': 'crops.SoilTestMethods',
        '_SoilTestPhosphorousKelownaRanges': 'crops.SoilTestPhosphorousKelownaRanges',
        '_SoilTestPhosphorousRecommendation': 'crops.SoilTestPhosphorousRecommendation',
        '_SoilTestPotassiumKelownaRanges': 'crops.SoilTestPotassiumKelownaRanges',
        '_SoilTestPotassiumRecommendation': 'crops.SoilTestPotassiumRecommendation',
        '_Previous_Crop_Types': 'crops.PreviousCropTypes',
    }
    
    for directory, model_path in directory_to_model.items():
        try:
            app_label, model_name = model_path.split('.')
            model = apps.get_model(app_label, model_name)
            model.objects.all().delete()
            print(f"Cleared all data from {model_path}")
        except Exception as e:
            print(f"Error clearing {model_path}: {str(e)}")


class Migration(migrations.Migration):

    dependencies = [
        ('shared', '0001_initial'),
        ('crops', '0001_initial'),
        ('animals', '0001_initial'),
        ('fertilizers', '0001_initial'),
        ('manures', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(
            seed_database,
            reverse_seed_database,
        ),
    ]
